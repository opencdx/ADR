package cdx.opencdx.adr.model;

import cdx.opencdx.adr.repository.ANFRepo;
import cdx.opencdx.grpc.data.RequestCircumstance;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.LinkedList;
import java.util.List;

/**
 * The {@code RequestCircumstanceModel} class represents a model for a request circumstance.
 * It is used to define the attributes and behavior of a request circumstance in the system.
 * The class is annotated with {@code @Entity} to indicate that it is a JPA entity.
 * The {@code @Table} annotation specifies the name of the database table to which this entity is mapped.
 * The class also includes private fields, getters, and setters for each attribute, as well as constructors for creating instances of the class.
 * <p>
 * Attributes:
 * - {@code id}: Represents an identifier for a specific entity in the system. It is of type {@code Long}.
 * - {@code timing}: Represents a measure model that defines a timing for a request circumstance. It is associated with a {@code MeasureModel} object.
 * - {@code priority}: Represents a priority in the context of a request circumstance. It is associated with a {@code LogicalExpressionModel} object.
 * - {@code requestedResult}: Represents a requested result in the context of a request circumstance. It is associated with a {@code MeasureModel} object.
 * - {@code repetition}: Represents a repetition in the context of a request circumstance. It is associated with a {@code RepetitionModel} object.
 * - {@code conditionalTrigger}: Represents a list of associated statement models that act as conditional triggers for the request circumstance.
 * - {@code purposes}: Represents a list of logical expressions that serve as purposes for the request circumstance.
 * - {@code requestedParticipant}: Represents a list of references to the requested participants for the request circumstance.
 * - {@code deviceIds}: Represents a list of device IDs associated with the request circumstance.
 * <p>
 * Example usage:
 * {@code RequestCircumstanceModel requestCircumstance = new RequestCircumstanceModel();}
 * {@code requestCircumstance.setTiming(new MeasureModel());}
 * {@code requestCircumstance.setPriority(new LogicalExpressionModel());}
 * ...
 */
@Getter
@Setter
@Entity
@NoArgsConstructor
@Table(name = "factrequestcircumstance")
public class RequestCircumstanceModel {
    /**
     * Represents an identifier for a specific entity in the system.
     * The {@code id} field is annotated with {@code @Id} to indicate that it is the primary key of the entity.
     * The {@code @GeneratedValue} annotation is used to specify the strategy for generating the value of the identifier.
     * In this case, the strategy is set to {@code GenerationType.IDENTITY}, which means that the identifier
     * is automatically generated by the database.
     * The {@code @Column} annotation is used to specify the details of the database column corresponding to the field.
     * The name of the column is set to "id", and it is marked as not nullable.
     * Lastly, the field is of type {@code Long} to represent a unique identifier.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    /**
     * Represents a measure model that defines a timing for a request circumstance.
     * It contains information such as upper bound, lower bound, inclusion of upper bound,
     * inclusion of lower bound, unit, semantic, and resolution.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "timing_id")
    private MeasureModel timing;

    /**
     * Represents a priority in the context of a request circumstance.
     * It is used to specify the importance or urgency of the circumstance.
     * The priority is associated with a logical expression.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "priority_id")
    private LogicalExpressionModel priority;

    /**
     * The requestedResult variable represents a MeasureModel object, which is a model class for storing information about a measurement.
     * It is associated with a RequestCircumstanceModel object through a many-to-one relationship.
     * The requestedResult field is fetched lazily from the database using the requested_result_id column of the associated table.
     * <p>
     * MeasureModel is a model class for a measurement entity, storing attributes such as upperBound, lowerBound, includeUpperBound, includeLowerBound, unit, semantic, and resolution
     * .
     * <p>
     * MeasureModel Declaration:
     * <p>
     * - upperBound: The upper bound of the measurement.
     * - lowerBound: The lower bound of the measurement.
     * - includeUpperBound: Indicates whether the upper bound is included in the measurement range.
     * - includeLowerBound: Indicates whether the lower bound is included in the measurement range.
     * - unit: The TinkarConceptModel representing the unit of measurement.
     * - semantic: The LogicalExpressionModel representing the semantic expression of the measurement.
     * - resolution: The resolution of the measurement.
     * <p>
     * Associated Classes:
     * <p>
     * - LogicalExpressionModel: A model class representing a logical expression entity.
     * - RepetitionModel: A model class representing a repetition entity.
     * - AssociatedStatementModel: A model class representing an associated statement entity.
     * - ReferenceModel: A model class representing a reference entity.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "requested_result_id")
    private MeasureModel requestedResult;

    /**
     *
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "repetition_id")
    private RepetitionModel repetition;

    /**
     * Represents a list of associated statement models that act as conditional triggers.
     * Conditional triggers are used to determine whether a request circumstance should be activated.
     * The list is annotated with @ManyToMany, indicating a many-to-many relationship with the "unionrequestcircumstance_conditionaltrigger" join table.
     * The join table specifies the foreign key columns for the RequestCircumstanceModel and AssociatedStatementModel entities.
     */
    @ManyToMany
    @JoinTable(
            name = "unionrequestcircumstance_conditionaltrigger",
            joinColumns = @JoinColumn(name = "request_circumstance_id"),
            inverseJoinColumns = @JoinColumn(name = "conditional_trigger_id"))
    private List<AssociatedStatementModel> conditionalTrigger = new LinkedList<>();

    /**
     * Represents a list of LogicalExpressionModel objects that serve as purposes for a union request circumstance.
     * <p>
     * The purposes are stored in a ManyToMany relationship with the UnionRequestCircumstanceModel class.
     * This allows multiple purposes to be associated with a single request circumstance.
     * <p>
     * The purposes are defined in the "unionrequestcircumstance_purpose" join table, which links the request circumstance and purpose entities.
     * <p>
     * Each purpose is an instance of the LogicalExpressionModel class, which represents a logical expression.
     * <p>
     * The LogicalExpressionModel class has the following attributes:
     * - id: The unique identifier for the logical expression.
     * - expression: The expression string that represents the logical expression.
     * - tinkarConcept: The associated TinkarConceptModel entity that represents the concept associated with the logical expression.
     * <p>
     * Example usage:
     * RequestCircumstanceModel requestCircumstance = new RequestCircumstanceModel();
     * LogicalExpressionModel purpose1 = new LogicalExpressionModel();
     * LogicalExpressionModel purpose2 = new LogicalExpressionModel();
     * requestCircumstance.getPurposes().add(purpose1);
     * requestCircumstance.getPurposes().add(purpose2);
     */
    @ManyToMany
    @JoinTable(
            name = "unionrequestcircumstance_purpose",
            joinColumns = @JoinColumn(name = "request_circumstance_id"),
            inverseJoinColumns = @JoinColumn(name = "purpose_id"))
    private List<LogicalExpressionModel> purposes = new LinkedList<>();


    /**
     *
     */
    @ManyToMany
    @JoinTable(
            name = "unionrequestcircumstance_requestedparticipant",
            joinColumns = @JoinColumn(name = "request_circumstance_id"),
            inverseJoinColumns = @JoinColumn(name = "requested_participant_id"))
    private List<ReferenceModel> requestedParticipant = new LinkedList<>();

    /**
     * The list of device IDs associated with the performance circumstance.
     */
    @ElementCollection  // For the list of deviceIds
    @CollectionTable(
            name = "requestCircumstance_DeviceId",
            joinColumns = @JoinColumn(name = "performance_circumstance_id")
    )
    @Column(name = "deviceId")
    private List<String> deviceIds;

    /**
     * Represents a model for a request circumstance.
     * It is used to construct an instance of RequestCircumstanceModel
     * by providing the necessary information.
     */
    public RequestCircumstanceModel(RequestCircumstance request, ANFRepo anfRepo) {
        this.timing = anfRepo.getMeasureRepository().save(new MeasureModel(request.getTiming(), anfRepo));
        this.priority = anfRepo.getLogicalExpressionRepository().saveOrFind(new LogicalExpressionModel(request.getPriority(), anfRepo));
        this.requestedResult = anfRepo.getMeasureRepository().save(new MeasureModel(request.getRequestedResult(), anfRepo));
        this.repetition = anfRepo.getRepetitionRepository().save(new RepetitionModel(request.getRepetition(), anfRepo));
        this.conditionalTrigger = request.getConditionalTriggerList().stream().map(trigger -> anfRepo.getAssociatedStatementRespository().save(new AssociatedStatementModel(trigger, anfRepo))).toList();
        this.purposes = request.getPurposeList().stream().map(purpose -> anfRepo.getLogicalExpressionRepository().saveOrFind(new LogicalExpressionModel(purpose, anfRepo))).toList();
        this.requestedParticipant = request.getRequestedParticipantList().stream().map(participant -> anfRepo.getReferenceRepository().save(new ReferenceModel(participant, anfRepo))).toList();
        this.deviceIds = request.getDeviceIdList();
    }
}